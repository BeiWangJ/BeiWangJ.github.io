<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="梳理 Human Parsing(人体解析) 相关介绍，数据集，算法">
<meta property="og:type" content="article">
<meta property="og:title" content="Human Parsing Survey">
<meta property="og:url" content="http://yoursite.com/2020/02/22/Human_Parsing_Survey/index.html">
<meta property="og:site_name" content="Bei&#39;s Blog">
<meta property="og:description" content="梳理 Human Parsing(人体解析) 相关介绍，数据集，算法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/JPPNET1.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/JPPNET2.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/JPPNET3.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/JPPNET4.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/JPPNET5.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/JPPNET6.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/CE2P1.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/CE2P2.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/CE2P3.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/CE2P4.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/ACE2P-pp1.jpg">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/ACE2P-pp2.jpg">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/ACE2P1.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/ACE2P2.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/ACE2P3.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/ACE2P4.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/ACE2P5.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/ACE2P6.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/ACE2P7.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/ACE2P8.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/ACE2P9.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/ACE2P10.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/ACE2P11.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/ACE2P12.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/ACE2P13.png">
<meta property="og:image" content="http://yoursite.com/images/human_parsing/Pascal-Person-Part-Dataset.png">
<meta property="article:published_time" content="2020-02-22T02:26:06.150Z">
<meta property="article:modified_time" content="2020-02-22T06:43:40.931Z">
<meta property="article:author" content="Bei">
<meta property="article:tag" content="cv">
<meta property="article:tag" content="human_parsing">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/human_parsing/JPPNET1.png">

<link rel="canonical" href="http://yoursite.com/2020/02/22/Human_Parsing_Survey/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Human Parsing Survey | Bei's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Bei's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/22/Human_Parsing_Survey/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bei's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Human Parsing Survey
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-22 10:26:06 / 修改时间：14:43:40" itemprop="dateCreated datePublished" datetime="2020-02-22T10:26:06+08:00">2020-02-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cv/" itemprop="url" rel="index">
                    <span itemprop="name">cv</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/02/22/Human_Parsing_Survey/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/02/22/Human_Parsing_Survey/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>梳理 Human Parsing(人体解析) 相关介绍，数据集，算法</p>
<a id="more"></a>
<!-- toc -->

<hr>
<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><hr>
<h2 id="Foreword"><a href="#Foreword" class="headerlink" title="Foreword"></a>Foreword</h2><ul>
<li>人体解析(Human Parsing)是细粒度的语义分割任务，旨在识别像素级别的人类图像的组成部分（例如，身体部位和服装）。</li>
</ul>
<h2 id="What-is-Human-Parsing"><a href="#What-is-Human-Parsing" class="headerlink" title="What is Human Parsing"></a>What is Human Parsing</h2><ul>
<li>different from pedestrian segmentation<ul>
<li>行人分割任务关注从图中抠出像素级的行人，目标可以是单人或者多人，往往是多人</li>
<li>人体解析关注将身体各部分像素级抠出，目标往往是单人</li>
</ul>
</li>
<li>semantic understanding of person<ul>
<li>像素级理解人体</li>
</ul>
</li>
<li>mul-label segmentation track<ul>
<li>是多类别分割任务</li>
</ul>
</li>
</ul>
<h2 id="Usage-of-Human-Parsing"><a href="#Usage-of-Human-Parsing" class="headerlink" title="Usage of Human Parsing"></a>Usage of Human Parsing</h2><ul>
<li>pedestrian attribution <ul>
<li>more precising than label learning when using as a front method of pedestrian attribute learning</li>
<li>现在行人属性学习有两种主思路<ul>
<li>mul-label learning<ul>
<li>使用标签对全图直接进行分类，使用attention进行unsupervised learning</li>
<li>优点：打标成本低，方便大规模使用</li>
<li>缺点：可靠性有待商榷</li>
</ul>
</li>
<li>mul-task learning <ul>
<li>使用人体解析作为前置，扣出后进行分析</li>
<li>优点：可靠，后续操作灵活，且自带粗略属性</li>
<li>缺点：打标成本极高</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Clothing Recommend<ul>
<li>Human Parsing 能够扣出<br>  -Hat<br>  -Hair<br>  -Glove<br>  -Sunglasses<br>  -Upper-clothes<br>  -Dress<br>  -Coat<br>  -Socks<br>  -Pants<br>  -Jumpsuits<br>  -Scarf<br>  -Skirt</li>
<li>在这个任务的基础上服饰的进一步解析推荐都是可期的</li>
</ul>
</li>
<li>pose estimation <ul>
<li>human parsing 能够扣出<ul>
<li>Face</li>
<li>Left-arm</li>
<li>Right-arm</li>
<li>Left-leg</li>
<li>Right-leg</li>
<li>Left-shoe</li>
<li>Right-shoe</li>
</ul>
</li>
<li>理论上是可以拿来做pose estimation和single frame的action recognition</li>
<li>有些数据集例如 LIP 同时拥有 人体关键点 和 人体解析 的标注，联合优化目前做的人不多，理论上可行，有待研究</li>
</ul>
</li>
<li>Re-ID<ul>
<li>使用 human parsing 做对其然后进行re-id</li>
<li>有人这么玩过效果不错但是消耗资源大，成本也高</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><hr>
<h2 id="JPPNet"><a href="#JPPNet" class="headerlink" title="JPPNet"></a>JPPNet</h2><ul>
<li><p>paper <a href="https://arxiv.org/pdf/1804.01984.pdf" target="_blank" rel="noopener">Look into Person: Joint Body Parsing &amp; Pose Estimation Network and A New Benchmark</a></p>
</li>
<li><p>github <a href="https://github.com/Engineering-Course/LIP_JPPNet" target="_blank" rel="noopener">https://github.com/Engineering-Course/LIP_JPPNet</a> </p>
</li>
<li><p><img src="/images/human_parsing/JPPNET1.png" alt="JPPNET1.png"></p>
</li>
<li><p><img src="/images/human_parsing/JPPNET2.png" alt="JPPNET2.png"></p>
</li>
<li><p>本文提出了 重量级的 human parsing benchmark – LIP</p>
</li>
<li><p>从数据集内容丰富度上看，之前的数据集中，MPII 和 LSP 就只有线，ATR就站着的，Pascaljiu 6种标，而LIP啥都有</p>
</li>
<li><p>从数据集本身数量上看， LIP也领先其他数据集许多</p>
</li>
<li><p>文章中提出了两种结构 JPPNet 以及 没有pose帮助的 SS-JPPNet，来看主结构</p>
</li>
<li><p><img src="/images/human_parsing/JPPNET3.png" alt="JPPNET3.png"></p>
</li>
<li><p>主要思想就是，共享backbone，fuse结果进行refine，具体是如何做的呢</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#backbone中提取对应特征 </span></span><br><span class="line">resnet_fea_100 = net_100.layers[<span class="string">'res4b22_relu'</span>]</span><br><span class="line">parsing_fea1_100 = net_100.layers[<span class="string">'res5d_branch2b_parsing'</span>]</span><br><span class="line">parsing_out1_100 = net_100.layers[<span class="string">'fc1_human'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#backbone中提取对应特征 </span></span><br><span class="line">resnet_fea_100 = net_100.layers[<span class="string">'res4b22_relu'</span>]</span><br><span class="line">parsing_fea1_100 = net_100.layers[<span class="string">'res5d_branch2b_parsing'</span>]</span><br><span class="line">parsing_out1_100 = net_100.layers[<span class="string">'fc1_human'</span>]</span><br><span class="line">    </span><br><span class="line"><span class="comment">#fc1_human是ASPP的output，出未refine的parsing结果。下面是源代码，是tf1.*的写法</span></span><br><span class="line">(self.feed(<span class="string">'res5b_relu'</span>,<span class="string">'bn5c_branch2c'</span>)</span><br><span class="line">.add(name=<span class="string">'res5c'</span>)</span><br><span class="line">.relu(name=<span class="string">'res5c_relu'</span>)</span><br><span class="line">.atrous_conv(<span class="number">3</span>, <span class="number">3</span>, n_classes, <span class="number">6</span>, padding=<span class="string">'SAME'</span>, relu=<span class="literal">False</span>, name=<span class="string">'fc1_human_c0'</span>))</span><br><span class="line">    </span><br><span class="line">(self.feed(<span class="string">'res5c_relu'</span>)</span><br><span class="line">.atrous_conv(<span class="number">3</span>, <span class="number">3</span>, n_classes, <span class="number">12</span>, padding=<span class="string">'SAME'</span>, relu=<span class="literal">False</span>, name=<span class="string">'fc1_human_c1'</span>))</span><br><span class="line"></span><br><span class="line">(self.feed(<span class="string">'res5c_relu'</span>)</span><br><span class="line">.atrous_conv(<span class="number">3</span>, <span class="number">3</span>, n_classes, <span class="number">18</span>, padding=<span class="string">'SAME'</span>, relu=<span class="literal">False</span>, name=<span class="string">'fc1_human_c2'</span>))</span><br><span class="line"></span><br><span class="line">(self.feed(<span class="string">'res5c_relu'</span>)</span><br><span class="line">.atrous_conv(<span class="number">3</span>, <span class="number">3</span>, n_classes, <span class="number">24</span>, padding=<span class="string">'SAME'</span>, relu=<span class="literal">False</span>, name=<span class="string">'fc1_human_c3'</span>))</span><br><span class="line"> </span><br><span class="line">(self.feed(<span class="string">'fc1_human_c0'</span>,</span><br><span class="line"><span class="string">'fc1_human_c1'</span>,</span><br><span class="line"><span class="string">'fc1_human_c2'</span>,</span><br><span class="line"><span class="string">'fc1_human_c3'</span>)</span><br><span class="line">.add(name=<span class="string">'fc1_human'</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#再结合posenet进行refine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pose_net</span><span class="params">(image, name)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(name) <span class="keyword">as</span> scope:</span><br><span class="line">        is_BN = <span class="literal">False</span></span><br><span class="line">        pose_conv1 = conv2d(image, <span class="number">512</span>, <span class="number">3</span>, <span class="number">1</span>, relu=<span class="literal">True</span>, bn=is_BN, name=<span class="string">'pose_conv1'</span>)</span><br><span class="line">        pose_conv2 = conv2d(pose_conv1, <span class="number">512</span>, <span class="number">3</span>, <span class="number">1</span>, relu=<span class="literal">True</span>, bn=is_BN, name=<span class="string">'pose_conv2'</span>)</span><br><span class="line">        pose_conv3 = conv2d(pose_conv2, <span class="number">256</span>, <span class="number">3</span>, <span class="number">1</span>, relu=<span class="literal">True</span>, bn=is_BN, name=<span class="string">'pose_conv3'</span>)</span><br><span class="line">        pose_conv4 = conv2d(pose_conv3, <span class="number">256</span>, <span class="number">3</span>, <span class="number">1</span>, relu=<span class="literal">True</span>, bn=is_BN, name=<span class="string">'pose_conv4'</span>)</span><br><span class="line">        pose_conv5 = conv2d(pose_conv4, <span class="number">256</span>, <span class="number">3</span>, <span class="number">1</span>, relu=<span class="literal">True</span>, bn=is_BN, name=<span class="string">'pose_conv5'</span>)</span><br><span class="line">        pose_conv6 = conv2d(pose_conv5, <span class="number">256</span>, <span class="number">3</span>, <span class="number">1</span>, relu=<span class="literal">True</span>, bn=is_BN, name=<span class="string">'pose_conv6'</span>)</span><br><span class="line">    </span><br><span class="line">        pose_conv7 = conv2d(pose_conv6, <span class="number">512</span>, <span class="number">1</span>, <span class="number">1</span>, relu=<span class="literal">True</span>, bn=is_BN, name=<span class="string">'pose_conv7'</span>)</span><br><span class="line">        pose_conv8 = conv2d(pose_conv7, <span class="number">16</span>, <span class="number">1</span>, <span class="number">1</span>, relu=<span class="literal">False</span>, bn=is_BN, name=<span class="string">'pose_conv8'</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> pose_conv8, pose_conv6   <span class="comment">#FCN结果，context</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pose_refine</span><span class="params">(pose, parsing, pose_fea, name)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(name) <span class="keyword">as</span> scope:</span><br><span class="line">        is_BN = <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 1*1 convolution remaps the heatmaps to match the number of channels of the intermediate features.</span></span><br><span class="line">        pose = conv2d(pose, <span class="number">128</span>, <span class="number">1</span>, <span class="number">1</span>, relu=<span class="literal">True</span>, bn=is_BN, name=<span class="string">'pose_remap'</span>)</span><br><span class="line">        parsing = conv2d(parsing, <span class="number">128</span>, <span class="number">1</span>, <span class="number">1</span>, relu=<span class="literal">True</span>, bn=is_BN, name=<span class="string">'parsing_remap'</span>)</span><br><span class="line">        <span class="comment"># concat </span></span><br><span class="line">        pos_par = tf.concat([pose, parsing, pose_fea], <span class="number">3</span>)</span><br><span class="line">        conv1 = conv2d(pos_par, <span class="number">512</span>, <span class="number">3</span>, <span class="number">1</span>, relu=<span class="literal">True</span>, bn=is_BN, name=<span class="string">'conv1'</span>)</span><br><span class="line">        conv2 = conv2d(conv1, <span class="number">256</span>, <span class="number">5</span>, <span class="number">1</span>, relu=<span class="literal">True</span>, bn=is_BN, name=<span class="string">'conv2'</span>)</span><br><span class="line">        conv3 = conv2d(conv2, <span class="number">256</span>, <span class="number">7</span>, <span class="number">1</span>, relu=<span class="literal">True</span>, bn=is_BN, name=<span class="string">'conv3'</span>)</span><br><span class="line">        conv4 = conv2d(conv3, <span class="number">256</span>, <span class="number">9</span>, <span class="number">1</span>, relu=<span class="literal">True</span>, bn=is_BN, name=<span class="string">'conv4'</span>)</span><br><span class="line">        conv5 = conv2d(conv4, <span class="number">256</span>, <span class="number">1</span>, <span class="number">1</span>, relu=<span class="literal">True</span>, bn=is_BN, name=<span class="string">'conv5'</span>)</span><br><span class="line">        conv6 = conv2d(conv5, <span class="number">16</span>, <span class="number">1</span>, <span class="number">1</span>, relu=<span class="literal">False</span>, bn=is_BN, name=<span class="string">'conv6'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> conv6, conv4 <span class="comment">#FCN结果，context</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parsing_refine</span><span class="params">(parsing, pose, parsing_fea, name)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(name) <span class="keyword">as</span> scope:</span><br><span class="line">        is_BN = <span class="literal">False</span></span><br><span class="line">        pose = conv2d(pose, <span class="number">128</span>, <span class="number">1</span>, <span class="number">1</span>, relu=<span class="literal">True</span>, bn=is_BN, name=<span class="string">'pose_remap'</span>)</span><br><span class="line">        parsing = conv2d(parsing, <span class="number">128</span>, <span class="number">1</span>, <span class="number">1</span>, relu=<span class="literal">True</span>, bn=is_BN, name=<span class="string">'parsing_remap'</span>)</span><br><span class="line">      </span><br><span class="line">        par_pos = tf.concat([parsing, pose, parsing_fea], <span class="number">3</span>)</span><br><span class="line">        parsing_conv1 = conv2d(par_pos, <span class="number">512</span>, <span class="number">3</span>, <span class="number">1</span>, relu=<span class="literal">True</span>, bn=is_BN, name=<span class="string">'parsing_conv1'</span>)</span><br><span class="line">        parsing_conv2 = conv2d(parsing_conv1, <span class="number">256</span>, <span class="number">5</span>, <span class="number">1</span>, relu=<span class="literal">True</span>, bn=is_BN, name=<span class="string">'parsing_conv2'</span>)</span><br><span class="line">        parsing_conv3 = conv2d(parsing_conv2, <span class="number">256</span>, <span class="number">7</span>, <span class="number">1</span>, relu=<span class="literal">True</span>, bn=is_BN, name=<span class="string">'parsing_conv3'</span>)</span><br><span class="line">        parsing_conv4 = conv2d(parsing_conv3, <span class="number">256</span>, <span class="number">9</span>, <span class="number">1</span>, relu=<span class="literal">True</span>, bn=is_BN, name=<span class="string">'parsing_conv4'</span>)</span><br><span class="line">      </span><br><span class="line">        parsing_conv5 = conv2d(parsing_conv4, <span class="number">256</span>, <span class="number">1</span>, <span class="number">1</span>, relu=<span class="literal">True</span>, bn=is_BN, name=<span class="string">'parsing_conv5'</span>)</span><br><span class="line">        parsing_human1 = atrous_conv2d(parsing_conv5, <span class="number">20</span>, <span class="number">3</span>, rate=<span class="number">6</span>, relu=<span class="literal">False</span>, name=<span class="string">'parsing_human1'</span>)</span><br><span class="line">        parsing_human2 = atrous_conv2d(parsing_conv5, <span class="number">20</span>, <span class="number">3</span>, rate=<span class="number">12</span>, relu=<span class="literal">False</span>, name=<span class="string">'parsing_human2'</span>)</span><br><span class="line">        parsing_human3 = atrous_conv2d(parsing_conv5, <span class="number">20</span>, <span class="number">3</span>, rate=<span class="number">18</span>, relu=<span class="literal">False</span>, name=<span class="string">'parsing_human3'</span>)</span><br><span class="line">        parsing_human4 = atrous_conv2d(parsing_conv5, <span class="number">20</span>, <span class="number">3</span>, rate=<span class="number">24</span>, relu=<span class="literal">False</span>, name=<span class="string">'parsing_human4'</span>)</span><br><span class="line">        parsing_human = tf.add_n([parsing_human1, parsing_human2, parsing_human3, parsing_human4], name=<span class="string">'parsing_human'</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> parsing_human, parsing_conv4 <span class="comment">#FCN结果，context</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>总体来说分以下几个步骤</p>
<ol>
<li>pose_out1_100, pose_fea1_100 = pose_net(resnet_fea_100, ‘fc1_pose’)  #先出一次pose结果</li>
<li>pose_out2_100, pose_fea2_100 = pose_refine(pose_out1_100, parsing_out1_100, pose_fea1_100, name=’fc2_pose’)  # 结合第一次parsing结果出第二次pose结果</li>
<li>parsing_out2_100, parsing_fea2_100 = parsing_refine( parsing_out1_100, pose_out1_100, parsing_fea1_100, name=’fc2_parsing’) # 结合第一次pose结果出第二次parsing结果</li>
<li>parsing_out3_100, parsing_fea3_100 = parsing_refine(parsing_out2_100, pose_out2_100, parsing_fea2_100, name=’fc3_parsing’) # 结合第二次pose结果出第三次parsing结果</li>
<li>pose_out3_100, pose_fea3_100 = pose_refine(pose_out2_100, parsing_out2_100, pose_fea2_100, name=’fc3_pose’) # 结合第二次parsing结果出第三次pose结果</li>
</ol>
</li>
<li><p>从代码上看，和论文里的图略有不同</p>
</li>
<li><p>loss</p>
<ul>
<li><img src="/images/human_parsing/JPPNET4.png" alt="JPPNET4.png"></li>
</ul>
</li>
<li><p>experiment</p>
<ul>
<li><img src="/images/human_parsing/JPPNET5.png" alt="JPPNET5.png"></li>
<li>从实验结果上看效果提升很明显，值得一赞</li>
</ul>
</li>
<li><p>more</p>
<ul>
<li>值得一提的是，SS-JPPNet 咋就和DeepLab差不多呢？上图</li>
<li><img src="/images/human_parsing/JPPNET6.png" alt="JPPNET6.png"></li>
<li>通过human parsing的9个部位，取其中心作为关键点进行训练，结果也是意料之中的没什么卵用。猜测是关键点结果还是来自于human parsing的结果，监督信息耦合。结果也是和deeplab相近</li>
</ul>
</li>
</ul>
<h2 id="CE2P"><a href="#CE2P" class="headerlink" title="CE2P"></a>CE2P</h2><ul>
<li>paper <a href="https://arxiv.org/pdf/1809.05996.pdf" target="_blank" rel="noopener">Devil in the Details: Towards Accurate Single and Multiple Human Parsing</a></li>
<li>github <a href="https://github.com/liutinglt/CE2P" target="_blank" rel="noopener">https://github.com/liutinglt/CE2P</a></li>
<li>参考链接 <a href="https://blog.csdn.net/siyue0211/article/details/90927712" target="_blank" rel="noopener">https://blog.csdn.net/siyue0211/article/details/90927712</a></li>
<li>标题很风骚，内容还是很硬核的</li>
<li>人体解析现在主要有两大类解决方案：<ol>
<li>High-resolution Maintenance，这种方法通过获得高分辨率的特征来恢复细节信息。它存在的问题是，由于卷积中的池化操作和卷积中的步长，会让最终生成的特征较小。解决方法是，删除一些下采样操作（max pooling etc.）或从一些低层特征中获取信息。</li>
<li>Context Information Embedding. 这种方法通过捕获丰富的上下文信息来处理多尺度的对象。ASPP和PSP是使用这一方式解决问题的主要结构。</li>
</ol>
</li>
<li>CE2P主要包括三大模块：<ol>
<li>一个高分辨率的embedding 模块，作用是放大特征图以恢复细节</li>
<li>一个全局上下文embedding 模块，作用是编码多尺度的上下文信息</li>
<li>一个边缘感知模块，用于整合对象轮廓的特征，以细化解析预测的边界</li>
</ol>
</li>
<li>Contribution<ol>
<li>作者分析了一些人脸解析方法，验证其有效性。并说明如何使用这些方法来达到更好的效果</li>
<li>作者利用了人脸解析中一些有效的方法，构建了CE2P框架</li>
<li>CE2P框架达到了公开数据集state-of-art的效果</li>
<li>代码开源，可以作为baseline使用</li>
</ol>
</li>
<li>下面来看看结构<ul>
<li><img src="/images/human_parsing/CE2P1.png" alt="CE2P1.png"></li>
<li>图中红色部分是PSPModule   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PSPModule</span><span class="params">(nn.Module)</span>:</span>  <span class="comment"># Pyramid scene parsing network</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Reference: </span></span><br><span class="line"><span class="string">    Zhao, Hengshuang, et al. *"Pyramid scene parsing network."*</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, features, out_features=<span class="number">512</span>, sizes=<span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>)</span>)</span>:</span></span><br><span class="line">        super(PSPModule, self).__init__()</span><br><span class="line">        self.stages = []</span><br><span class="line">        self.stages = nn.ModuleList([self._make_stage(features, out_features, size) <span class="keyword">for</span> size <span class="keyword">in</span> sizes])</span><br><span class="line">        self.bottleneck = nn.Sequential(</span><br><span class="line">            nn.Conv2d(features+len(sizes)*out_features, out_features, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, dilation=<span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            InPlaceABNSync(out_features),</span><br><span class="line">            )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_make_stage</span><span class="params">(self, features, out_features, size)</span>:</span></span><br><span class="line">        prior = nn.AdaptiveAvgPool2d(output_size=(size, size))</span><br><span class="line">        conv = nn.Conv2d(features, out_features, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        bn = InPlaceABNSync(out_features)</span><br><span class="line">        <span class="keyword">return</span> nn.Sequential(prior, conv, bn)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, feats)</span>:</span></span><br><span class="line">        h, w = feats.size(<span class="number">2</span>), feats.size(<span class="number">3</span>)</span><br><span class="line">        priors = [ F.interpolate(input=stage(feats), size=(h, w), mode=<span class="string">'bilinear'</span>, align_corners=<span class="literal">True</span>) <span class="keyword">for</span> stage <span class="keyword">in</span> self.stages] + [feats]</span><br><span class="line">        bottle = self.bottleneck(torch.cat(priors, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> bottle</span><br></pre></td></tr></table></figure></li>
<li>黄色部分是 high-res 的module，常规的conv cat操作  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decoder_Module</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_classes)</span>:</span></span><br><span class="line">        super(Decoder_Module, self).__init__()</span><br><span class="line">        self.conv1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">512</span>, <span class="number">256</span>, kernel_size=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            InPlaceABNSync(<span class="number">256</span>)</span><br><span class="line">            )</span><br><span class="line">        self.conv2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">256</span>, <span class="number">48</span>, kernel_size=<span class="number">1</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            InPlaceABNSync(<span class="number">48</span>)</span><br><span class="line">            )</span><br><span class="line">        self.conv3 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">304</span>, <span class="number">256</span>, kernel_size=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            InPlaceABNSync(<span class="number">256</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">256</span>, <span class="number">256</span>, kernel_size=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            InPlaceABNSync(<span class="number">256</span>)</span><br><span class="line">            )</span><br><span class="line">        self.conv4 = nn.Conv2d(<span class="number">256</span>, num_classes, kernel_size=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, bias=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, xt, xl)</span>:</span></span><br><span class="line">        _, _, h, w = xl.size()</span><br><span class="line"></span><br><span class="line">        xt = F.interpolate(self.conv1(xt), size=(h, w), mode=<span class="string">'bilinear'</span>, align_corners=<span class="literal">True</span>)</span><br><span class="line">        xl = self.conv2(xl)</span><br><span class="line">        x = torch.cat([xt, xl], dim=<span class="number">1</span>)</span><br><span class="line">        x = self.conv3(x)</span><br><span class="line">        seg = self.conv4(x)</span><br><span class="line">        <span class="keyword">return</span> seg, x</span><br></pre></td></tr></table></figure></li>
<li>绿色部分是本文的亮点 Edge_Module，一方面提取了边缘特征信息，另一方面得到了edge图用于计算loss，从代码上看也是非常普通的做法  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge_Module</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,in_fea=[<span class="number">256</span>,<span class="number">512</span>,<span class="number">1024</span>], mid_fea=<span class="number">256</span>, out_fea=<span class="number">2</span>)</span>:</span></span><br><span class="line">        super(Edge_Module, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self.conv1 =  nn.Sequential(</span><br><span class="line">            nn.Conv2d(in_fea[<span class="number">0</span>], mid_fea, kernel_size=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            InPlaceABNSync(mid_fea)</span><br><span class="line">            ) </span><br><span class="line">        self.conv2 =  nn.Sequential(</span><br><span class="line">            nn.Conv2d(in_fea[<span class="number">1</span>], mid_fea, kernel_size=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            InPlaceABNSync(mid_fea)</span><br><span class="line">            )  </span><br><span class="line">        self.conv3 =  nn.Sequential(</span><br><span class="line">            nn.Conv2d(in_fea[<span class="number">2</span>], mid_fea, kernel_size=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            InPlaceABNSync(mid_fea)</span><br><span class="line">        )</span><br><span class="line">        self.conv4 = nn.Conv2d(mid_fea,out_fea, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, dilation=<span class="number">1</span>, bias=<span class="literal">True</span>)</span><br><span class="line">        self.conv5 = nn.Conv2d(out_fea*<span class="number">3</span>,out_fea, kernel_size=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, bias=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x1, x2, x3)</span>:</span></span><br><span class="line">        _, _, h, w = x1.size()</span><br><span class="line">        </span><br><span class="line">        edge1_fea = self.conv1(x1)</span><br><span class="line">        edge1 = self.conv4(edge1_fea)</span><br><span class="line">        edge2_fea = self.conv2(x2)</span><br><span class="line">        edge2 = self.conv4(edge2_fea)</span><br><span class="line">        edge3_fea = self.conv3(x3)</span><br><span class="line">        edge3 = self.conv4(edge3_fea)        </span><br><span class="line">        </span><br><span class="line">        edge2_fea =  F.interpolate(edge2_fea, size=(h, w), mode=<span class="string">'bilinear'</span>,align_corners=<span class="literal">True</span>) </span><br><span class="line">        edge3_fea =  F.interpolate(edge3_fea, size=(h, w), mode=<span class="string">'bilinear'</span>,align_corners=<span class="literal">True</span>) </span><br><span class="line">        edge2 =  F.interpolate(edge2, size=(h, w), mode=<span class="string">'bilinear'</span>,align_corners=<span class="literal">True</span>)</span><br><span class="line">        edge3 =  F.interpolate(edge3, size=(h, w), mode=<span class="string">'bilinear'</span>,align_corners=<span class="literal">True</span>) </span><br><span class="line"> </span><br><span class="line">        edge = torch.cat([edge1, edge2, edge3], dim=<span class="number">1</span>)</span><br><span class="line">        edge = self.conv5(edge)</span><br><span class="line"></span><br><span class="line">        edge_fea = torch.cat([edge1_fea, edge2_fea, edge3_fea], dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> edge, edge_fea</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Note that the edge annotation used in the edge perceiving module is directly generated from the parsing annotation by extracting border between different semantics.<ul>
<li>仅是使用parsing的annotation，就生成了edge的annotation<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_edge</span><span class="params">(label, edge_width=<span class="number">3</span>)</span>:</span></span><br><span class="line">    h, w = label.shape</span><br><span class="line">    edge = np.zeros(label.shape)    </span><br><span class="line">    <span class="comment"># right</span></span><br><span class="line">    edge_right = edge[<span class="number">1</span>:h, :]</span><br><span class="line">        edge_right[(label[<span class="number">1</span>:h, :] != label[:h - <span class="number">1</span>, :]) &amp; (label[<span class="number">1</span>:h, :] != <span class="number">255</span>)</span><br><span class="line">                  &amp; (label[:h - <span class="number">1</span>, :] != <span class="number">255</span>)] = <span class="number">1</span>  </span><br><span class="line">    <span class="comment"># up</span></span><br><span class="line">    edge_up = edge[:, :w - <span class="number">1</span>]</span><br><span class="line">        edge_up[(label[:, :w - <span class="number">1</span>] != label[:, <span class="number">1</span>:w])</span><br><span class="line">               &amp; (label[:, :w - <span class="number">1</span>] != <span class="number">255</span>)</span><br><span class="line">               &amp; (label[:, <span class="number">1</span>:w] != <span class="number">255</span>)] = <span class="number">1</span>    </span><br><span class="line">    <span class="comment"># upright</span></span><br><span class="line">    edge_upright = edge[:h - <span class="number">1</span>, :w - <span class="number">1</span>]</span><br><span class="line">        edge_upright[(label[:h - <span class="number">1</span>, :w - <span class="number">1</span>] != label[<span class="number">1</span>:h, <span class="number">1</span>:w])</span><br><span class="line">                    &amp; (label[:h - <span class="number">1</span>, :w - <span class="number">1</span>] != <span class="number">255</span>)</span><br><span class="line">                    &amp; (label[<span class="number">1</span>:h, <span class="number">1</span>:w] != <span class="number">255</span>)] = <span class="number">1</span> </span><br><span class="line">    <span class="comment"># bottomright</span></span><br><span class="line">    edge_bottomright = edge[:h - <span class="number">1</span>, <span class="number">1</span>:w]</span><br><span class="line">        edge_bottomright[(label[:h - <span class="number">1</span>, <span class="number">1</span>:w] != label[<span class="number">1</span>:h, :w - <span class="number">1</span>])</span><br><span class="line">                        &amp; (label[:h - <span class="number">1</span>, <span class="number">1</span>:w] != <span class="number">255</span>)</span><br><span class="line">                        &amp; (label[<span class="number">1</span>:h, :w - <span class="number">1</span>] != <span class="number">255</span>)] = <span class="number">1</span>  </span><br><span class="line">    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (edge_width, edge_width))</span><br><span class="line">    edge = cv2.dilate(edge, kernel)</span><br><span class="line">    <span class="keyword">return</span> edge</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>LOSS<ul>
<li><img src="/images/human_parsing/CE2P2.png" alt="CE2P2.png"></li>
<li>CE三连</li>
</ul>
</li>
<li>Experiment<ul>
<li><img src="/images/human_parsing/CE2P3.png" alt="CE2P3.png"></li>
<li>在不适用point的监督信息的情况下mIOU还提升了不少，比deeplab提升近9个点(20%)，在test集上，结果非常惊艳，远超JPP</li>
<li><img src="/images/human_parsing/CE2P4.png" alt="CE2P4.png"></li>
</ul>
</li>
<li>非常强大的结构，非常值得作为baseline使用</li>
</ul>
<h2 id="ACE2P-pp"><a href="#ACE2P-pp" class="headerlink" title="ACE2P-pp"></a>ACE2P-pp</h2><ul>
<li>git <a href="https://github.com/PaddlePaddle/PaddleSeg/tree/release/v0.1.0/contrib/ACE2P" target="_blank" rel="noopener">https://github.com/PaddlePaddle/PaddleSeg/tree/release/v0.1.0/contrib/ACE2P</a></li>
<li>目前的总统山榜首是 paddleseg 的 Augmented Context Embedding with Edge Perceiving(ACE2P)</li>
<li>ACE2P有两个版本，此处版本为rank 1的paddleseg版本，只有inference版本，paddlepaddle是静态图，具体信息的放出也比较有限</li>
<li>改编自 Devil in the Details: Towards Accurate Single and Multiple Human Parsing <a href="https://arxiv.org/abs/1809.05996" target="_blank" rel="noopener">https://arxiv.org/abs/1809.05996</a></li>
<li>结构图 </li>
<li><img src="/images/human_parsing/ACE2P-pp1.jpg" alt="ACE2P1.jpg"></li>
<li>ACE2P模型包含三个分支:<ol>
<li>语义分割分支</li>
<li>边缘检测分支</li>
<li>融合分支</li>
</ol>
</li>
<li>语义分割分支采用resnet101作为backbone,通过Pyramid Scene Parsing Network融合上下文信息以获得更加精确的特征表征</li>
<li>边缘检测分支采用backbone的中间层特征作为输入，预测二值边缘信息</li>
<li>融合分支将语义分割分支以及边缘检测分支的特征进行融合，以获得边缘细节更加准确的分割图像。</li>
<li>分割问题一般采用mIoU作为评价指标，特别引入了IoU loss结合cross-entropy loss以针对性优化这一指标</li>
<li>测试阶段，采用多尺度以及水平翻转的结果进行融合生成最终预测结果</li>
<li>训练阶段，采用余弦退火的学习率策略， 并且在学习初始阶段采用线性warm up</li>
<li>数据预处理方面，保持图片比例并进行随机缩放，随机旋转，水平翻转作为数据增强策略</li>
<li>LIP指标<ul>
<li>该模型在测试尺度为’377,377,473,473,567,567’且水平翻转的情况下，meanIoU为62.63</li>
<li>多模型ensemble后meanIoU为65.18, 居LIP Single-Person Human Parsing Track榜单第一</li>
</ul>
</li>
<li><img src="/images/human_parsing/ACE2P-pp2.jpg" alt="ACE2P2.jpg"></li>
<li>主要思想来自于 CE2P</li>
<li>和CE2P相比，几乎没有太多的变化，仅仅多了从 edge 分支 到fuse分支一条线路</li>
<li>目前的LIP第一，使用paddlepaddle架构，放出了模型和推论脚本，没有训练脚本</li>
</ul>
<h2 id="ACE2P"><a href="#ACE2P" class="headerlink" title="ACE2P"></a>ACE2P</h2><ul>
<li>paper <a href="https://arxiv.org/pdf/1910.09777.pdf" target="_blank" rel="noopener">Self-Correction for Human Parsing</a></li>
<li>该篇文章为ACE2P rank3版本，学术版本，10月22日首次挂在arxiv</li>
<li>git <a href="https://github.com/PeikeLi/Self-Correction-Human-Parsing" target="_blank" rel="noopener">https://github.com/PeikeLi/Self-Correction-Human-Parsing</a></li>
<li>git版本只有inference，不过值得一提的是，由于使用的是pytorch，model是开放的可见的，对比ce2p后发现基本结构基本没有不同，区别在于loss和schp方法</li>
<li><img src="/images/human_parsing/ACE2P1.png" alt="ACE2P1.png"></li>
<li>展示了schp随cycle改进pred的效果</li>
<li><img src="/images/human_parsing/ACE2P2.png" alt="ACE2P2.png"></li>
<li>framework和paddleseg的基本一直，只是将loss function展开了，其中consistency constraint是一个新玩意。其中还有一点没有确定的是，ce2p是明显有三个输出的framework，这里的这个看样子仅有两个输出，有待实验确定</li>
<li><img src="/images/human_parsing/ACE2P3.png" alt="ACE2P3.png"></li>
<li>loss的第一部分是objective loss，是cls loss（bce） + miou loss。文中的[1] The Lovasz-Softmax loss: A tractable surrogate for the optimization of the ´ intersection-over-union measure in neural networks 是针对miou进行优化的loss，git <a href="https://github.com/bermanmaxim/LovaszSoftmax，有兴趣的同学可以点进去看看" target="_blank" rel="noopener">https://github.com/bermanmaxim/LovaszSoftmax，有兴趣的同学可以点进去看看</a></li>
<li><img src="/images/human_parsing/ACE2P4.png" alt="ACE2P4.png"></li>
<li>一致性约束。主要是为了回应他前文所说的<ul>
<li>Second, CE2P only implicitly facilitates the parsing results with the edge predictions by feature-level fusion. There is no explicit constraint to ensure the parsing results maintaining the same geometry shape of the boundary predictions.</li>
</ul>
</li>
<li>这个edge module是否真的是帮助了pred，这里比对了pred中的edge和pred中fuse后gen出的edge，以保证这个fuse是靠谱的</li>
<li><img src="/images/human_parsing/ACE2P5.png" alt="ACE2P5.png"></li>
<li>loss<ul>
<li>We choose the ResNet-set. 101 [12] as the backbone of the feature extractor and use an ImageNet [8] pre-trained weights. Specifically, we fix the first three residual layers and set the stride size of last residual layer to 1 with a dilation rate of 2. In this way, the final output is enlarged to 1/16 resolution size w.r.t the original image. We adopt pyramid scene parsing network [33] as the context encoding module. We use 473 × 473 as the input resolution. Training is done with a total batch size of 36. For our joint loss function, we set the weight of each term as λ1 = 1, λ2 = 1, λ3 = 0.1. The initial learning rate is set as 7e-3 with a linear increasing warm-up strategy for 10 epochs. We train our network for 150 epochs in total for a fair comparison, the first 100 epochs as initialization following 5 cycles each contains 10 epochs of the self-correction process.</li>
</ul>
</li>
<li>训练细节<ul>
<li><img src="/images/human_parsing/ACE2P6.png" alt="ACE2P6.png"></li>
<li>展示了schp的策略，先训练了100个epoch作为Cycle 0 base，然后使用 anneal cosine decay lr策略restart4次，将权重结合，模型效果就会像是ensemble了一样，越来越好</li>
<li><img src="/images/human_parsing/ACE2P7.png" alt="ACE2P7.png"></li>
<li>这个weight aggregation也是很直白的，w0是init的，m=1 w1 = m/(m+1) * w0 + 1/(m+1)w = 1/2<em>w0 + 1/2</em>w，就是一个移动平均</li>
<li>After updating the current model weight with the former optimal one from the last cycle, we forward all the training data for one epoch to re-estimate the statistics of the parameters (i.e. moving average and standard deviation) in all batch normalization [14] layers. During these successive cycles of model aggregation, the network leads to wider model optima as well as improved model’s generalization ability.</li>
<li>作者也提到说模型融合的时候需要一个epoch来使BN层适应</li>
<li><img src="/images/human_parsing/ACE2P8.png" alt="ACE2P8.png"></li>
<li>这个是说，怕这个label坑爹，使用原始的label init y0，使用pred结果更新label，机制和weight一样</li>
<li><img src="/images/human_parsing/ACE2P9.png" alt="ACE2P9.png"></li>
<li>schp的核心算法，每经过一次cycle，更新w，BN的parameter（mean var）不算w，额外更新下，使用新的w计算pred的y，更新y</li>
</ul>
</li>
<li>Experiment<ul>
<li><img src="/images/human_parsing/ACE2P10.png" alt="ACE2P10.png"></li>
<li>ACE2P效果就很棒，加上SCHP，效果超CE2P一大截</li>
<li><img src="/images/human_parsing/ACE2P11.png" alt="ACE2P11.png"></li>
<li>在 Pascal-Person-Part val上表现也同样不俗，使用简单的test技巧后达到了sota</li>
<li><img src="/images/human_parsing/ACE2P12.png" alt="ACE2P12.png"></li>
<li>作者还在LIP上做了不同backbone的SCHP实验，使用SCHP能普涨一个点以上；当使用不同context encoding模块，使用了SCHP后，PSP ，ASPP，OCNet都得到了一个点以上的提升，差距缩小</li>
<li><img src="/images/human_parsing/ACE2P13.png" alt="ACE2P13.png"></li>
<li>说明了3个额外loss的可靠性；说明了schp中模型融合和label的refine都是有效果的</li>
</ul>
</li>
<li>CE2P是正式在semantic segmentation中开启了human parsing分支，ACE2P是大幅改进了性能，都是非常推荐精读细读的文章</li>
</ul>
<hr>
<h1 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h1><hr>
<h2 id="LIP"><a href="#LIP" class="headerlink" title="LIP"></a>LIP</h2><ul>
<li>look into person</li>
<li>home <a href="http://sysu-hcp.net/lip/overview.php" target="_blank" rel="noopener">http://sysu-hcp.net/lip/overview.php</a></li>
<li>Human-Cyber-Physical Intelligence Integration Lab of Sun Yat-sen University （中山大学人机物智能融合实验室出品）</li>
<li>Overview<ul>
<li>Look into Person (LIP) is a new large-scale dataset, focus on semantic understanding of person. Following are the detailed descriptions.<ul>
<li>Volume<ul>
<li>The dataset contains 50,000 images with elaborated pixel-wise annotations with 19 semantic human part labels and 2D human poses with 16 key points.</li>
</ul>
</li>
<li>Diversity<ul>
<li>The annotated 50,000 images are cropped person instances from COCO dataset with size larger than 50 * 50.The images collected from the real-world scenarios contain human appearing with challenging poses and views, heavily occlusions, various appearances and low-resolutions. We are working on collecting and annotating more images to increase diversity.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Four Track<ol>
<li>Single Person （Main）<ul>
<li>We have divided images into three sets. 30462 images for training set, 10000 images for validation set and 10000 for testing set.The dataset is available at <a href="https://drive.google.com/drive/folders/0BzvH3bSnp3E9ZW9paE9kdkJtM3M?usp=sharing" target="_blank" rel="noopener">Google Drive</a> and <a href="http://pan.baidu.com/s/1nvqmZBN" target="_blank" rel="noopener">Baidu Drive</a>.</li>
<li>Besides we have another large dataset mentioned in “<a href="http://www.cv-foundation.org/openaccess/content_iccv_2015/html/Liang_Human_Parsing_With_ICCV_2015_paper.html" target="_blank" rel="noopener">Human parsing with contextualized convolutional neural network.” ICCV’15</a>, which focuses on fashion images. You can download the dataset including 17000 images as extra training data.</li>
</ul>
</li>
<li>Multi-Person  (CHIP)<ul>
<li>To stimulate the multiple-human parsing research, we collect the images with multiple person instances to establish the first standard and comprehensive benchmark for instance-level human parsing. Our Crowd Instance-level Human Parsing Dataset (CIHP) contains 28280 training, 5000 validation and 5000 test images, in which there are 38280 multiple-person images in total.</li>
<li>You can also downlod this dataset at <a href="https://drive.google.com/drive/folders/0BzvH3bSnp3E9ZW9paE9kdkJtM3M?usp=sharing" target="_blank" rel="noopener">Google Drive</a> and <a href="http://pan.baidu.com/s/1nvqmZBN" target="_blank" rel="noopener">Baidu Drive</a>.</li>
</ul>
</li>
<li>Video Multi-Person Human Parsing<ul>
<li>VIP(Video instance-level Parsing) dataset, the first video multi-person human parsing benchmark, consists of 404 videos covering various scenarios. For every 25 consecutive frames in each video, one frame is annotated densely with pixel-wise semantic part categories and instance-level identification. There are 21247 densely annotated images in total. We divide these 404 sequences into 304 train sequences, 50 validation sequences and 50 test sequences.</li>
<li>You can also downlod this dataset at <a href="https://1drv.ms/f/s!ArFSFaZzVErwgSHRpiJNJTzgMR8j" target="_blank" rel="noopener">OneDrive</a> and <a href="https://pan.baidu.com/s/18_PVNy7FCh4T74nVzRXbtA" target="_blank" rel="noopener">Baidu Drive</a>.<ul>
<li>VIP_Fine: All annotated images and fine annotations for train and val sets.</li>
<li>VIP_Sequence: 20-frame surrounding each VIP_Fine image (-10 | +10).</li>
<li>VIP_Videos: 404 video sequences of VIP dataset.</li>
</ul>
</li>
</ul>
</li>
<li>Image-based Multi-pose Virtual Try On<ul>
<li>MPV (Multi-Pose Virtual try on) dataset, which consists of 35,687/13,524 person/clothes images, with the resolution of 256x192. Each person has different poses. We split them into the train/test set 52,236/10,544 three-tuples, respectively.</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="MHP"><a href="#MHP" class="headerlink" title="MHP"></a>MHP</h2><ul>
<li>Multi-Human Parsing</li>
<li>home <a href="https://lv-mhp.github.io/" target="_blank" rel="noopener">https://lv-mhp.github.io/</a></li>
<li>Learning and Vision (LV) Group, National University of Singapore (NUS) (新加坡国立大学机器学习与视觉小组)</li>
<li>Statistics<ul>
<li>MHP v1.0<ul>
<li>The MHP v1.0 dataset contains 4,980 images, each with at least two persons (average is 3). We randomly choose 980 images and their corresponding annotations as the testing set. The rest form a training set of 3,000 images and a validation set of 1,000 images. For each instance, 18 semantic categories are defined and annotated except for the “background” category, i.e. “hat”, “hair”, “sunglasses”, “upper clothes”, “skirt”, “pants”, “dress”, “belt”, “left shoe”, “right shoe”, “face”, “left leg”, “right leg”, “left arm”, “right arm”, “bag”, “scarf” and “torso skin”. Each instance has a complete set of annotations whenever the corresponding category appears in the current image.</li>
</ul>
</li>
<li>MHP v2.0<ul>
<li>The MHP v2.0 dataset contains 25,403 images, each with at least two persons (average is 3). We randomly choose 5,000 images and their corresponding annotations as the testing set. The rest form a training set of 15,403 images and a validation set of 5,000 images. For each instance, 58 semantic categories are defined and annotated except for the “background” category, i.e. “cap/hat”, “helmet”, “face”, “hair”, “left- arm”, “right-arm”, “left-hand”, “right-hand”, “protector”, “bikini/bra”, “jacket/windbreaker/hoodie”, “t-shirt”, “polo-shirt”, “sweater”, “sin- glet”, “torso-skin”, “pants”, “shorts/swim-shorts”, “skirt”, “stock- ings”, “socks”, “left-boot”, “right-boot”, “left-shoe”, “right-shoe”, “left- highheel”, “right-highheel”, “left-sandal”, “right-sandal”, “left-leg”, “right-leg”, “left-foot”, “right-foot”, “coat”, “dress”, “robe”, “jumpsuits”, “other-full-body-clothes”, “headwear”, “backpack”, “ball”, “bats”, “belt”, “bottle”, “carrybag”, “cases”, “sunglasses”, “eyewear”, “gloves”, “scarf”, “umbrella”, “wallet/purse”, “watch”, “wristband”, “tie”, “other-accessaries”, “other-upper-body-clothes”, and “other-lower-body-clothes”. Each instance has a complete set of annotations whenever the corresponding category appears in the current image.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Pascal-Person-Part-Dataset"><a href="#Pascal-Person-Part-Dataset" class="headerlink" title="Pascal-Person-Part Dataset"></a>Pascal-Person-Part Dataset</h2><ul>
<li>1,716 images for training and 1,817 for testing</li>
<li>first mentioned paper <a href="https://arxiv.org/pdf/1406.2031.pdf" target="_blank" rel="noopener">Detect What You Can: Detecting and Representing Objects using Holistic Models and Body Parts</a><ul>
<li>没找到下载的地方= =。。标注了part</li>
</ul>
</li>
<li>second paper <a href="https://arxiv.org/pdf/1708.03383.pdf" target="_blank" rel="noopener">Joint Multi-Person Pose Estimation and Semantic Part Segmentation</a><ul>
<li><a href="https://sukixia.github.io/materials/pascal_data.zip" target="_blank" rel="noopener">download link</a></li>
<li>附加标注了key-point</li>
<li>提出了联合学习方法<ul>
<li><img src="/images/human_parsing/Pascal-Person-Part-Dataset.png" alt="Pascal-Person-Part-Dataset.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ATR"><a href="#ATR" class="headerlink" title="ATR"></a>ATR</h2><ul>
<li>project url <a href="http://www.sysu-hcp.net/deep-human-parsing/" target="_blank" rel="noopener">link</a></li>
<li>paper <a href="https://www.cv-foundation.org/openaccess/content_iccv_2015/papers/Liang_Human_Parsing_With_ICCV_2015_paper.pdf" target="_blank" rel="noopener">Human Parsing with Contextualized Convolutional Neural Network</a></li>
<li>Human parsing is to predict every pixel with 18 labels: face, sunglass, hat, scarf, hair, upperclothes, left-arm, right-arm, belt, pants, left-leg, right-leg, skirt, left-shoe, right-shoe, bag, dress and null. Totally, 7,700 images are included in the ATR dataset [15], 6,000 for training, 1,000 for testing and 700 for validation1 . T</li>
<li>download link <a href="https://github.com/lemondan/HumanParsing-Dataset" target="_blank" rel="noopener">link</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/cv/" rel="tag"># cv</a>
              <a href="/tags/human-parsing/" rel="tag"># human_parsing</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/22/Crowd_Counting_Survey/" rel="prev" title="Crowd Counting Survey ">
      <i class="fa fa-chevron-left"></i> Crowd Counting Survey 
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/02/22/Pedestrian_Attribute_Recognition_Survey/" rel="next" title="Pedestrian Attribute Recognition Survey">
      Pedestrian Attribute Recognition Survey <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Intro"><span class="nav-number">1.</span> <span class="nav-text">Intro</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Foreword"><span class="nav-number">1.1.</span> <span class="nav-text">Foreword</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#What-is-Human-Parsing"><span class="nav-number">1.2.</span> <span class="nav-text">What is Human Parsing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Usage-of-Human-Parsing"><span class="nav-number">1.3.</span> <span class="nav-text">Usage of Human Parsing</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Algorithm"><span class="nav-number">2.</span> <span class="nav-text">Algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JPPNet"><span class="nav-number">2.1.</span> <span class="nav-text">JPPNet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CE2P"><span class="nav-number">2.2.</span> <span class="nav-text">CE2P</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ACE2P-pp"><span class="nav-number">2.3.</span> <span class="nav-text">ACE2P-pp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ACE2P"><span class="nav-number">2.4.</span> <span class="nav-text">ACE2P</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Dataset"><span class="nav-number">3.</span> <span class="nav-text">Dataset</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#LIP"><span class="nav-number">3.1.</span> <span class="nav-text">LIP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MHP"><span class="nav-number">3.2.</span> <span class="nav-text">MHP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pascal-Person-Part-Dataset"><span class="nav-number">3.3.</span> <span class="nav-text">Pascal-Person-Part Dataset</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ATR"><span class="nav-number">3.4.</span> <span class="nav-text">ATR</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bei"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Bei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bei</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'dJ0rQquk22lsdG4t3BrB9qyt-9Nh9j0Va',
      appKey     : 'kcDcreWpivcr3LFMi97jrt4k',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
